vertex, vertices - wierzchołek, wierzchołki

- używać zamiast #define:
    - const
    - inline function()
- manipulatory w iostream, takie jak endl
- Rzutowanie:
  - safe casts: static_cast<type>
  - reinterpret_cast: niebezpieczne, równoważne z (type) z C (które jest deprecated), bardzo niebezpieczne
  - dynamic_cast<type> używane w klasach, w specyficznych przypadkach, raczej nie używać
  - const_cast<type>

- operator overload:
  - unary operator:
    - preincrement ++
      type operator++(type v) {return static_cast<type>(v=v+1);}
    - postincrement ++
      type operator++ (type& v, int) { type temp = v; v = temp+1; return temp; }
  - binary operator 
    operator + (type& val1, type& val2) { return (val1.x + val2.x); }
    
- nullptr   - new keyword (type safe) for NULL pointer, or '0' pointer
- deep vs shallow copy

--------------------------------------------------------------------------------
- Grafy
  - complete graph with 4 nodes: K4 - naming convention
  - complete graph - every ode is connected to every other
  - degree of node: how many edges goes from that node (vertex). In K4 every node is degree of 3
  - seven bridges of königsberg - probalem, który Leonhard Euler udowodnił dzięki teorii grafów. Dlatego algorytm przejścia przez wszystkie krawędzie dokładnie raz, nazywany cyklem Eulerowskim
- Najpopularniejsze reprezentacje grafów:
    - connectivity matrix (zawierająca wagi lub odległości)
    - edge list - wygodne gdy graf jest niepełny (many nodes with low degree, for example: 100 nodes with degree 4)
    - tradeoffs - graph as an ADT
- List representation:
   - directed graph with N vertices using an array of N lists of vertices
   - weighted graph may be represented with a list of vertex / weight pairs
   - undirected graph ma be represented by having vertex j in the list for vertex i and vertex i in the list for vertex j.
example:
- matrix:
    1 2 3 4
  1 1 1 1 1
  2 1 0 0 0
  3 0 1 0 1
  4 0 1 1 0
- list:   
  1 -> 1 -> 2 -> 3 -> 4
  2 -> 1
  3 -> 2 -> 4
  4 -> 2 -> 3

- Dijkstra shortest path
  - definitions:
    - "closed nodes set" that have known shortest distances
    - "opens nodes set" - what is reachable
  - find shortest path between start and destination node s to d
  - step 1: include s in a closed set and all immediate successors of s with ther distance in the open set
  - step 2: pick the open node of least cost - say this node is n
  - 

  use list representation and implement dijkstra algorithm (also you can implement for matrix imaplementation)

http://graphonline.ru/en/?graph=KXdTUOPYKsvARtQu

--------------------------------------------------------------------------------

MST

* Homework3:
Find MSP when edges must be of specified color or pair of colors

class enum color {RED, BLUE, GREEN}


* Jarnik-Prim Minimum Spanning Tree (czeski matematyk, opisał w 1930)
- if there is no connection from one node to the rest of the graph, then we have disconnected (disjoined) graph
  - graph disconnected: there is no spanning tree
  - graph connected (every node can reach every none in the graph)
  - Spanning tree can be paunched only for connected graph
  - Avoid loops
  - for N nodes graph, the MST cost would be N-1 if every edge has unit cost 1
  

* Jarnik-Prim algo:
 - Start at A
 - Nearest is E
 - Pick nearest next node - until
 - All nodes in graph or no more nodes to connect
4.3 - pseudo code in 4:30

* Kruskal's Algorithm
 - make a sorted list of edges
 - take another from the list
 - check if both nodes from the edge are not in reached nodes: avoid loops
 - stop if all nodes are reached 

--------------------------------------------------------------------------------
* Vector methods
  vector<int> v;
  v.size();
  v.resize(int size);
- constructors (many of them):
  vector<T> v; //empty vector
  vector<T> v(int n) // size n vector
  
--------------------------------------------------------------------------------
* range for statement
  for (declaration : expression )
    statement
  double data_d[] = {1.2, 2.2, 4.4, 5.5 };
    double sumd = 0.0;
    for (auto& d: data_d)
        sumd += d;
    
  
--------------------------------------------------------------------------------
Iterators
- categories (Five iterator categories) from weakest to strongest:
  - input - read, single pass: for example read input file
  - output - write, single pass
  - forward - read and write, mutlipass - 1D
  - bidirectional, multi-pass +2 directions
  - Random access (strongest), anywhere

In STL the design principle is to use the weakest iterator that accomodates the most efficient algorithm. 
For example quicksort requires random access. As a consequence it cannot be used on a non-random access container such as a list. Because quicksort is called "partition exchange"

The iterator hierarchy:
1. input iterator
  ++ sequention move
  * access operator
  sequential access elements in input stream.
  find(elem) in a collection searched sequentially
  == and != are defined also








